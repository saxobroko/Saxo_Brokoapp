<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Tron</title>

  <!-- Basic styling, centering of the canvas. -->
  <style>

  #body_{
        background-color: #512E5F
    }

    canvas {
    		display: block;
    		position: absolute;
    		border: 1px solid #000;
    		margin: auto;
    		top: 0;
    		bottom: 0;
    		right: 0;
    		left: 0;
    	}
  </style>
</head>

<body id="body_">
        <div style="background-color:#fff">
                <br>
                <h3>1st Player(PURPLE)<br> left=A,right=D<br>up=W,down=S</h3>
                </div>
            <div style="background-color:#21fe41">
                <h3></h3>
                <br>
                <h3>__PRESS F5 key to Replay__</h3>
                <br>
                <h3></h3>
            </div>
  <script>
    var
    /**
     * Constats
     */
    COLS = 40,
    ROWS = 40,
    EMPTY = 0,
    SNAKE = 1,
    SNAKE_ = 3,
    SNAKE_O = 4,
    FENCE = 2,

    LEFT  = 0,
    UP    = 1,
    RIGHT = 2,
    DOWN  = 3,

	LEFT_  = 4,
	UP_    = 5,
	RIGHT_ = 6,
	DOWN_  = 7,

    LEFT_O  = 8,
    UP_O    = 9,
    RIGHT_O = 10,
    DOWN_O  = 11,

    KEY_LEFT  = 12,
    KEY_UP    = 13,
    KEY_RIGHT = 14,
    KEY_DOWN  = 15,

	KEY_LEFT_  = 16,
    KEY_UP_    = 17,
    KEY_RIGHT_ = 18,
    KEY_DOWN_  = 19,

    KEY_LEFT_O  = 65,
    KEY_UP_O    = 87,
    KEY_RIGHT_O = 68,
    KEY_DOWN_O  = 83,

    COUNT=0,

    C=1,
    C_=1,
    C_O=1,

    SN=1,
    SN_=3,
    SN_O=4,
    /**
     * Game objects
     */
    canvas,	  /* HTMLCanvas */
    ctx,	  /* CanvasRenderingContext2d */
    keystate, /* Object, used for keyboard inputs */
    frames,   /* number, used for animation */
    score;	  /* number, keep track of the player score */
    /**
     * Grid datastructor, usefull in games where the game world is
     * confined in absolute sized chunks of data or information.
     * 
     * @type {Object}
     */
    grid = {
    	width: null,  /* number, the number of columns */
    	height: null, /* number, the number of rows */
    	_grid: null,  /* Array<any>, data representation */
    	/**
    	 * Initiate and fill a c x r grid with the value of d
    	 * @param  {any}    d default value to fill with
    	 * @param  {number} c number of columns
    	 * @param  {number} r number of rows
    	 */
    	init: function(d, c, r) {
    		this.width = c;
    		this.height = r;
    		this._grid = [];
    		for (var x=0; x < c; x++) {
    			this._grid.push([]);
    			for (var y=0; y < r; y++) {
    				this._grid[x].push(d);
    			}
    		}
    	},
    	/**
    	 * Set the value of the grid cell at (x, y)
    	 * 
    	 * @param {any}    val what to set
    	 * @param {number} x   the x-coordinate
    	 * @param {number} y   the y-coordinate
    	 */
    	set: function(val, x, y) {
    		this._grid[x][y] = val;
    	},
    	/**
    	 * Get the value of the cell at (x, y)
    	 * 
    	 * @param  {number} x the x-coordinate
    	 * @param  {number} y the y-coordinate
    	 * @return {any}   the value at the cell
    	 */
    	get: function(x, y) {
    		return this._grid[x][y];
    	}
    }
    /**
     * The snake, works as a queue (FIFO, first in first out) of data
     * with all the current positions in the grid with the snake id
     * 
     * @type {Object}
     */
    snake = {
    	direction: null, /* number, the direction */
    	last: null,		 /* Object, pointer to the last element in
    						the queue */
    	_queue: null,	 /* Array<number>, data representation*/
    	/**
    	 * Clears the queue and sets the start position and direction
    	 * 
    	 * @param  {number} d start direction
    	 * @param  {number} x start x-coordinate
    	 * @param  {number} y start y-coordinate
    	 */
    	init: function(d, x, y) {
    		this.direction = d;
    		this._queue = [];
    		this.insert(x, y);
    	},
    	/**
    	 * Adds an element to the queue
    	 * 
    	 * @param  {number} x x-coordinate
    	 * @param  {number} y y-coordinate
    	 */
    	insert: function(x, y) {
    		// unshift prepends an element to an array
    		this._queue.unshift({x:x, y:y});
    		this.last = this._queue[0];
    	},
    	/**
    	 * Removes and returns the first element in the queue.
    	 * 
    	 * @return {Object} the first element
    	 */
    	remove: function() {
    		// pop returns the last element of an array
    		return this._queue.pop();
    	}
    };



    snake_ = {
    	direction_: null, /* number, the direction */
    	last_: null,		 /* Object, pointer to the last element in
    						the queue */
    	_queue_: null,	 /* Array<number>, data representation*/
    	/**
    	 * Clears the queue and sets the start position and direction
    	 * 
    	 * @param  {number} d start direction
    	 * @param  {number} x start x-coordinate
    	 * @param  {number} y start y-coordinate
    	 */
    	init_: function(d, x, y) {
    		this.direction_ = d;
    		this._queue_ = [];
    		this.insert_(x, y);
    	},
    	/**
    	 * Adds an element to the queue
    	 * 
    	 * @param  {number} x x-coordinate
    	 * @param  {number} y y-coordinate
    	 */
    	insert_: function(x, y) {
    		// unshift prepends an element to an array
    		this._queue_.unshift({x:x, y:y});
    		this.last_ = this._queue_[0];
    	},
    	/**
    	 * Removes and returns the first element in the queue.
    	 * 
    	 * @return {Object} the first element
    	 */
    	remove_: function() {
    		// pop returns the last element of an array
    		return this._queue_.pop();
    	}
    };



    snake_O = {
        direction_O: null, /* number, the direction */
        last_O: null,         /* Object, pointer to the last element in
                            the queue */
        _queue_O: null,   /* Array<number>, data representation*/
        /**
         * Clears the queue and sets the start position and direction
         * 
         * @param  {number} d start direction
         * @param  {number} x start x-coordinate
         * @param  {number} y start y-coordinate
         */
        init_O: function(d, x, y) {
            this.direction_O = d;
            this._queue_O = [];
            this.insert_O(x, y);
        },
        /**
         * Adds an element to the queue
         * 
         * @param  {number} x x-coordinate
         * @param  {number} y y-coordinate
         */
        insert_O: function(x, y) {
            // unshift prepends an element to an array
            this._queue_O.unshift({x:x, y:y});
            this.last_O = this._queue_O[0];
        },
        /**
         * Removes and returns the first element in the queue.
         * 
         * @return {Object} the first element
         */
        remove_O: function() {
            // pop returns the last element of an array
            return this._queue_O.pop();
        }
    };


	


    function main() {
    	// create and initiate the canvas element
    	canvas = document.createElement("canvas");
    	canvas.width = COLS*15;
    	canvas.height = ROWS*15;
    	ctx = canvas.getContext("2d");
    	// add the canvas element to the body of the document
    	document.body.appendChild(canvas);
    	// sets an base font for bigger score display
    	ctx.font = "12px Helvetica";
    	frames = 0;
    	keystate = {};
    	// keeps track of the keybourd input
    	document.addEventListener("keydown", function(evt) {
    		keystate[evt.keyCode] = true;
    	});
    	document.addEventListener("keyup", function(evt) {
    		delete keystate[evt.keyCode];
    	});
    	// intatiate game objects and starts the game loop
		setFence();
    	init();
    	loop();
		
    }
    /**
     * Resets and inits game objects
     */
	function setFence(){
		
	}

	
    function init() {
        COUNT=0;
        C=1;
        C_=1;
        C_O=1;
        SN=1,
        SN_=3,
        SN_O=4,
    	score = 0;
    	grid.init(EMPTY, COLS, ROWS);
    	

		
			for(var y = 0 ; y < grid.height; y++){
    		 	grid.set(FENCE,0,y);
			}
			for(var y = 0 ; y < grid.height; y++){
    		 	grid.set(FENCE,grid.width-1,y);
			}
		
			for(var x = 0 ; x < grid.width; x++){
    		 	grid.set(FENCE,x,0);
			}

			for(var x = 0 ; x < grid.width; x++){
    		 	grid.set(FENCE,x,grid.height-1);
			}
		// if(y == 0 || y == grid.height-1){
		// 	
		// }

    	//1
    	var sp = {x:Math.floor(COLS*2/3), y:ROWS/2};
    	snake.init(UP, sp.x, sp.y);
    	grid.set(SNAKE, sp.x, sp.y);

    	//2
    	var sq = {x:Math.floor(COLS/2), y:ROWS/2};
    	snake_.init_(DOWN_, sq.x, sq.y);
    	grid.set(SNAKE_, sq.x, sq.y);


        var sx = {x:Math.floor(COLS/3), y:ROWS/2};
        snake_O.init_O(UP_O, sx.x, sx.y);
        grid.set(SNAKE_O, sx.x, sx.y);


    	//setFood();
    }
    /**
     * The game loop function, used for game updates and rendering
     */
    function loop() {
    	update();
    	draw();
    	// When ready to redraw the canvas call the loop function
    	// first. Runs about 60 frames a second
    	window.requestAnimationFrame(loop, canvas);
    }
    /**
     * Updates the game logic
     */
    function update() {
    	frames++;
    	// changing direction of the snake depending on which keys
    	// that are pressed
    	if (keystate[KEY_LEFT] && snake.direction !== RIGHT) {
    		snake.direction = LEFT;
    	}
    	if (keystate[KEY_UP] && snake.direction !== DOWN) {
    		snake.direction = UP;
    	}
    	if (keystate[KEY_RIGHT] && snake.direction !== LEFT) {
    		snake.direction = RIGHT;
    	}
    	if (keystate[KEY_DOWN] && snake.direction !== UP) {
    		snake.direction = DOWN;
    	}




    	if (keystate[KEY_LEFT_] && snake_.direction_ !== RIGHT_) {
    		snake_.direction_ = LEFT_;
    	}
    	if (keystate[KEY_UP_] && snake_.direction_ !== DOWN_) {
    		snake_.direction_ = UP_;
    	}
    	if (keystate[KEY_RIGHT_] && snake_.direction_ !== LEFT_) {
    		snake_.direction_ = RIGHT_;
    	}
    	if (keystate[KEY_DOWN_] && snake_.direction_ !== UP_) {
    		snake_.direction_ = DOWN_;
    	}




        if (keystate[KEY_LEFT_O] && snake_O.direction_O !== RIGHT_O) {
            snake_O.direction_O = LEFT_O;
        }
        if (keystate[KEY_UP_O] && snake_O.direction_O !== DOWN_O) {
            snake_O.direction_O = UP_O;
        }
        if (keystate[KEY_RIGHT_O] && snake_O.direction_O !== LEFT_O) {
            snake_O.direction_O = RIGHT_O;
        }
        if (keystate[KEY_DOWN_O] && snake_O.direction_O !== UP_O) {
            snake_O.direction_O = DOWN_O;
        }


		
			


    	// each five frames update the game state.
    	if (frames%5 === 0) {
    		// pop the last element from the snake queue i.e. the
    		// head
    		var nx = snake.last.x;
    		var ny = snake.last.y;

    		var qx = snake_.last_.x;
    		var qy = snake_.last_.y;

            var ox = snake_O.last_O.x;
            var oy = snake_O.last_O.y;
    		// updates the position depending on the snake direction
    		switch (snake.direction) {
    			case LEFT:
    				nx--;
    				break;
    			case UP:
    				ny--;
    				break;
    			case RIGHT:
    				nx++;
    				break;
    			case DOWN:
    				ny++;
    				break;
    		}


    		switch (snake_.direction_) {
    			case LEFT_:
    				qx--;
    				break;
    			case UP_:
    				qy--;
    				break;
    			case RIGHT_:
    				qx++;
    				break;
    			case DOWN_:
    				qy++;
    				break;
    		}


            switch (snake_O.direction_O) {
                case LEFT_O:
                    ox--;
                    break;
                case UP_O:
                    oy--;
                    break;
                case RIGHT_O:
                    ox++;
                    break;
                case DOWN_O:
                    oy++;
                    break;
            }

			
			if(snake.direction == RIGHT){
				
				if(grid.get(nx+2, ny) != EMPTY){
					if(grid.get(nx, ny-1) != EMPTY &&
						grid.get(nx, ny+1) != EMPTY &&
						grid.get(nx+2, ny) != EMPTY){
							snake.direction = RIGHT;
					}
					else if(grid.get(nx, ny+1) != EMPTY&&
					 	grid.get(nx+2, ny) != EMPTY)
					{
						snake.direction = UP;
					}
					else if(grid.get(nx, ny-1) != EMPTY&&
					 	grid.get(nx+2, ny) != EMPTY)
					{
						snake.direction = DOWN;
					}
					else
						{
							if(grid.get(nx, ny+1) != EMPTY ||
							 grid.get(nx, ny+2) != EMPTY)
								{
									snake.direction = UP ;
								}
							else if(grid.get(nx, ny-1) != EMPTY||
							 grid.get(nx, ny-2) != EMPTY)
								{
									snake.direction = DOWN ;
								}
							else{
								var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0){
										snake.direction = DOWN;
									}
									else{
										snake.direction = UP;
									}
								}
						}
				}

				if(grid.get(nx+1, ny) != EMPTY){
					if(grid.get(nx, ny-1) != EMPTY &&
						grid.get(nx, ny+1) != EMPTY &&
						grid.get(nx+1, ny) != EMPTY){
							snake.direction = RIGHT;
					}
					else if(grid.get(nx, ny+1) != EMPTY&&
					 	grid.get(nx+1, ny) != EMPTY)
					{
						snake.direction = UP;
					}
					else if(grid.get(nx, ny-1) != EMPTY&&
					 	grid.get(nx+1, ny) != EMPTY)
					{
						snake.direction = DOWN;
					}
					else
						{
							if(grid.get(nx, ny+1) != EMPTY ||
							 grid.get(nx, ny+2) != EMPTY)
								{
									snake.direction = UP ;
								}
							else if(grid.get(nx, ny-1) != EMPTY||
							 grid.get(nx, ny-2) != EMPTY)
								{
									snake.direction = DOWN ;
								}
							else{
								var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0){
										snake.direction = DOWN;
									}
									else{
										snake.direction = UP;
									}
								}
						}
				}

			}
			if(snake.direction == LEFT){


				if(grid.get(nx-2, ny) != EMPTY){
					if(grid.get(nx, ny-1) != EMPTY &&
						grid.get(nx, ny+1) != EMPTY &&
						grid.get(nx-2, ny) != EMPTY){
							snake.direction = LEFT;
					}
					else if(grid.get(nx, ny+1) != EMPTY&&
					 	grid.get(nx-2, ny) != EMPTY)
					{
						snake.direction = UP;
					}
					else if(grid.get(nx, ny-1) != EMPTY&&
					 	grid.get(nx-2, ny) != EMPTY)
					{
						snake.direction = DOWN;
					}
					else
						{
							if(grid.get(nx, ny+1) != EMPTY ||
							 grid.get(nx, ny+2) != EMPTY)
								{
									snake.direction = UP ;
								}
							else if(grid.get(nx, ny-1) != EMPTY||
							 grid.get(nx, ny-2) != EMPTY)
								{
									snake.direction = DOWN ;
								}
							else{
								var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0){
										snake.direction = DOWN;
									}
									else{
										snake.direction = UP;
									}
								}
						}
				}

				if(grid.get(nx+1, ny) != EMPTY){
					if(grid.get(nx, ny-1) != EMPTY &&
						grid.get(nx, ny+1) != EMPTY &&
						grid.get(nx+1, ny) != EMPTY){
							snake.direction = RIGHT;
					}
					else if(grid.get(nx, ny+1) != EMPTY&&
					 	grid.get(nx+1, ny) != EMPTY)
					{
						snake.direction = UP;
					}
					else if(grid.get(nx, ny-1) != EMPTY&&
					 	grid.get(nx+1, ny) != EMPTY)
					{
						snake.direction = DOWN;
					}
					else
						{
							if(grid.get(nx, ny+1) != EMPTY ||
							 grid.get(nx, ny+2) != EMPTY)
								{
									snake.direction = UP ;
								}
							else if(grid.get(nx, ny-1) != EMPTY||
							 grid.get(nx, ny-2) != EMPTY)
								{
									snake.direction = DOWN ;
								}
							else{
								var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0){
										snake.direction = DOWN;
									}
									else{
										snake.direction = UP;
									}
								}
						}
				}


			}
			
			if(snake.direction == DOWN){

				if(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE)
				   {
					if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 		grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE))
						{
							snake.direction = DOWN;
				 		}
					else if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 		grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE))
						{
							snake.direction = LEFT;
						}
					else if((grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 		grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE))
						{
							snake.direction = RIGHT;
						}
					else{
							if(grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
							grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE ||
							grid.get(nx+2, ny) == SNAKE ||grid.get(nx+2, ny) == SNAKE_||
							grid.get(nx+2, ny) == SNAKE_O||grid.get(nx+2, ny) == FENCE)
								{
									snake.direction = LEFT ;
								}
							else if(grid.get(nx-1, ny) == SNAKE|| grid.get(nx-1, ny) == SNAKE_||
							grid.get(nx-1, ny) == SNAKE_O|| grid.get(nx-1, ny) == FENCE ||
							grid.get(nx-2, ny) == SNAKE|| grid.get(nx-2, ny) == SNAKE_||
							grid.get(nx-2, ny) == SNAKE_O|| grid.get(nx-2, ny) == FENCE)
								{
									snake.direction = RIGHT ;
								}
							else{
									var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0)
									{
										snake.direction = LEFT;
									}
									else{
										snake.direction = RIGHT;
									}
								}
						}
				}

				if(grid.get(nx, ny+1) == SNAKE || grid.get(nx, ny+1) == SNAKE_||
				 grid.get(nx, ny+1) == SNAKE_O|| grid.get(nx, ny+1) == FENCE)
				 {
				 if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 		grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE))
						{
							snake.direction = DOWN;
				 		}
					else if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 		grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE))
						{
							snake.direction = LEFT;
						}
					else if((grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny+2) == SNAKE || grid.get(nx, ny+2) == SNAKE_||
				 		grid.get(nx, ny+2) == SNAKE_O|| grid.get(nx, ny+2) == FENCE))
						{
							snake.direction = RIGHT;
						}
					else{
							if(grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
							grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE ||
							grid.get(nx+2, ny) == SNAKE ||grid.get(nx+2, ny) == SNAKE_||
							grid.get(nx+2, ny) == SNAKE_O||grid.get(nx+2, ny) == FENCE)
								{
									snake.direction = LEFT ;
								}
							else if(grid.get(nx-1, ny) == SNAKE|| grid.get(nx-1, ny) == SNAKE_||
							grid.get(nx-1, ny) == SNAKE_O|| grid.get(nx-1, ny) == FENCE ||
							grid.get(nx-2, ny) == SNAKE|| grid.get(nx-2, ny) == SNAKE_||
							grid.get(nx-2, ny) == SNAKE_O|| grid.get(nx-2, ny) == FENCE)
								{
									snake.direction = RIGHT ;
								}
							else{
									var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0)
									{
										snake.direction = LEFT;
									}
									else{
										snake.direction = RIGHT;
									}
								}
						}
				}

			}
			if(snake.direction == UP){

				if(grid.get(nx, ny-2) == SNAKE || grid.get(nx, ny-2) == SNAKE_||
				 grid.get(nx, ny-2) == SNAKE_O|| grid.get(nx, ny-2) == FENCE)
				   {
					if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny-2) == SNAKE || grid.get(nx, ny-2) == SNAKE_||
				 		grid.get(nx, ny-2) == SNAKE_O|| grid.get(nx, ny-2) == FENCE))
						{
							snake.direction = UP;
				 		}
					else if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&
						(grid.get(nx, ny-2) == SNAKE || grid.get(nx, ny-2) == SNAKE_||
				 		grid.get(nx, ny-2) == SNAKE_O|| grid.get(nx, ny-2) == FENCE))
						{
							snake.direction = LEFT;
						}
					else if((grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny-2) == SNAKE || grid.get(nx, ny-2) == SNAKE_||
				 		grid.get(nx, ny-2) == SNAKE_O|| grid.get(nx, ny-2) == FENCE))
						{
							snake.direction = RIGHT;
						}
					else{
							if(grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
							grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE ||
							grid.get(nx+2, ny) == SNAKE ||grid.get(nx+2, ny) == SNAKE_||
							grid.get(nx+2, ny) == SNAKE_O||grid.get(nx+2, ny) == FENCE)
								{
									snake.direction = LEFT ;
								}
							else if(grid.get(nx-1, ny) == SNAKE|| grid.get(nx-1, ny) == SNAKE_||
							grid.get(nx-1, ny) == SNAKE_O|| grid.get(nx-1, ny) == FENCE ||
							grid.get(nx-2, ny) == SNAKE|| grid.get(nx-2, ny) == SNAKE_||
							grid.get(nx-2, ny) == SNAKE_O|| grid.get(nx-2, ny) == FENCE)
								{
									snake.direction = RIGHT ;
								}
							else{
									var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0){
										snake.direction = RIGHT;
									}
									else{
										snake.direction = LEFT;
									}
								}
						}
				}

				if(grid.get(nx, ny-1) == SNAKE || grid.get(nx, ny-1) == SNAKE_||
				 grid.get(nx, ny-1) == SNAKE_O|| grid.get(nx, ny-1) == FENCE)
				 {
				 if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny-1) == SNAKE || grid.get(nx, ny-1) == SNAKE_||
				 		grid.get(nx, ny-1) == SNAKE_O|| grid.get(nx, ny-1) == FENCE))
						{
							snake.direction = UP;
				 		}
					else if((grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
				 	   grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE)&&
						(grid.get(nx, ny-1) == SNAKE || grid.get(nx, ny-1) == SNAKE_||
				 		grid.get(nx, ny-1) == SNAKE_O|| grid.get(nx, ny-1) == FENCE))
						{
							snake.direction = LEFT;
						}
					else if((grid.get(nx-1, ny) == SNAKE ||grid.get(nx-1, ny) == SNAKE_||
				 	   grid.get(nx-1, ny) == SNAKE_O||grid.get(nx-1, ny) == FENCE)&&
						(grid.get(nx, ny-1) == SNAKE || grid.get(nx, ny-1) == SNAKE_||
				 		grid.get(nx, ny-1) == SNAKE_O|| grid.get(nx, ny-1) == FENCE))
						{
							snake.direction = RIGHT;
						}
					else{
							if(grid.get(nx+1, ny) == SNAKE ||grid.get(nx+1, ny) == SNAKE_||
							grid.get(nx+1, ny) == SNAKE_O||grid.get(nx+1, ny) == FENCE ||
							grid.get(nx+2, ny) == SNAKE ||grid.get(nx+2, ny) == SNAKE_||
							grid.get(nx+2, ny) == SNAKE_O||grid.get(nx+2, ny) == FENCE)
								{
									snake.direction = LEFT ;
								}
							else if(grid.get(nx-1, ny) == SNAKE|| grid.get(nx-1, ny) == SNAKE_||
							grid.get(nx-1, ny) == SNAKE_O|| grid.get(nx-1, ny) == FENCE ||
							grid.get(nx-2, ny) == SNAKE|| grid.get(nx-2, ny) == SNAKE_||
							grid.get(nx-2, ny) == SNAKE_O|| grid.get(nx-2, ny) == FENCE)
								{
									snake.direction = RIGHT ;
								}
							else{
									var direction_condition=Math.floor(Math.random()*100);
									if(direction_condition % 2 == 0){
										snake.direction = RIGHT;
									}
									else{
										snake.direction = LEFT;
									}
								}
						}
				}


			}

            if(snake_.direction_ == RIGHT_){
                

                if(grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                   grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE)
                   {
                    if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                       grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                       grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE))
                        {
                            snake_.direction_ = RIGHT_;
                        }
                    else if((grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                       grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE))
                        {
                            snake_.direction_ = UP_;
                        }
                    else if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                        grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE))
                        {
                            snake_.direction_ = DOWN_;
                        }
                    else
                        {
                            if(grid.get(qx, qy+1) == SNAKE || grid.get(qx, qy+1) == SNAKE_||
                                grid.get(qx, qy+1) == SNAKE_O|| grid.get(qx, qy+1) == FENCE ||
                                grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                                grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE)
                                {
                                    snake_.direction_ = UP_ ;
                                }
                            else if(grid.get(qx, qy-1) == SNAKE|| grid.get(qx, qy-1) == SNAKE_||
                                grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE ||
                                grid.get(qx, qy-2) == SNAKE|| grid.get(qx, qy-2) == SNAKE_||
                                grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE)
                                {
                                    snake_.direction_ = DOWN_ ;
                                }
                            else{
                                var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0){
                                        snake_.direction_ = DOWN_;
                                    }
                                    else{
                                        snake_.direction_ = UP_;
                                    }
                                }
                        }
                }
                if(grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                 grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)
                 {
                    if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                       grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                        grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE))
                        {
                            snake_.direction_ = RIGHT_;
                        }
                    else if((grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                        grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE))
                        {
                            snake_.direction_ = UP_;
                        }
                    else if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                        grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE))
                        {
                            snake_.direction_ = DOWN_;
                        }
                    else
                        {
                            if(grid.get(qx, qy+1) == SNAKE || grid.get(qx, qy+1) == SNAKE_||
                                grid.get(qx, qy+1) == SNAKE_O|| grid.get(qx, qy+1) == FENCE ||
                                grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                                grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE)
                                {
                                    snake_.direction_ = UP_ ;
                                }
                            else if(grid.get(qx, qy-1) == SNAKE|| grid.get(qx, qy-1) == SNAKE_||
                                grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE ||
                                grid.get(qx, qy-2) == SNAKE|| grid.get(qx, qy-2) == SNAKE_||
                                grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE)
                                {
                                    snake_.direction_ = DOWN_ ;
                                }
                            else{
                                var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0){
                                        snake_.direction_ = DOWN_;
                                    }
                                    else{
                                        snake_.direction_ = UP_;
                                    }
                                }
                        }
                }


            }
            if(snake_.direction_ == LEFT_){
                if(grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                   grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE)
                   {
                    if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                       grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                        grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE))
                        {
                            snake_.direction_ = LEFT_;
                        }
                    else if((grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                         grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE))
                        {
                            snake_.direction_ = UP_;
                        }
                    else if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                        grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE))
                        {
                            snake_.direction_ = DOWN_;
                        }
                    else
                        {
                            if(grid.get(qx, qy+1) == SNAKE || grid.get(qx, qy+1) == SNAKE_||
                                grid.get(qx, qy+1) == SNAKE_O|| grid.get(qx, qy+1) == FENCE ||
                                grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                                grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE)
                                {
                                    snake_.direction_ = UP_ ;
                                }
                            else if(grid.get(qx, qy-1) == SNAKE|| grid.get(qx, qy-1) == SNAKE_||
                                grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE ||
                                grid.get(qx, qy-2) == SNAKE|| grid.get(qx, qy-2) == SNAKE_||
                                grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE)
                                {
                                    snake_.direction_ = DOWN_ ;
                                }
                            else{
                                var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0){
                                        snake_.direction_ = UP_;
                                    }
                                    else{
                                        snake_.direction_ = DOWN_;
                                    }
                            }
                        }
                }

                if(grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                 grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)
                 {
                    if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                       grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                        grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE))
                        {
                            snake_.direction_ = LEFT_;
                        }
                    else if((grid.get(qx, qy+1) == SNAKE ||grid.get(qx, qy+1) == SNAKE_||
                       grid.get(qx, qy+1) == SNAKE_O||grid.get(qx, qy+1) == FENCE)&&
                        (grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                        grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE))
                        {
                            snake_.direction_ = UP_;
                        }
                    else if((grid.get(qx, qy-1) == SNAKE ||grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O||grid.get(qx, qy-1) == FENCE)&&
                        (grid.get(qx-2, qy) == SNAKE ||grid.get(qx-2, qy) == SNAKE_||
                        grid.get(qx-2, qy) == SNAKE_O||grid.get(qx-2, qy) == FENCE))
                        {
                            snake_.direction_ = DOWN_;
                        }
                    else
                        {
                            if(grid.get(qx, qy+1) == SNAKE || grid.get(qx, qy+1) == SNAKE_||
                                grid.get(qx, qy+1) == SNAKE_O|| grid.get(qx, qy+1) == FENCE ||
                                grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                                grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE)
                                {
                                    snake_.direction_ = UP_ ;
                                }
                            else if(grid.get(qx, qy-1) == SNAKE|| grid.get(qx, qy-1) == SNAKE_||
                                grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE ||
                                grid.get(qx, qy-2) == SNAKE|| grid.get(qx, qy-2) == SNAKE_||
                                grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE)
                                {
                                    snake_.direction_ = DOWN_ ;
                                }
                            else{
                                var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0){
                                        snake_.direction_ = UP_;
                                    }
                                    else{
                                        snake_.direction_ = DOWN_;
                                    }
                            }
                        }
                }


            }
            
            if(snake_.direction_ == DOWN_){

                if(grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                 grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE)
                   {
                    if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                        grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE))
                        {
                            snake_.direction_ = DOWN_;
                        }
                    else if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                        grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE))
                        {
                            snake_.direction_ = LEFT_;
                        }
                    else if((grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                        grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE))
                        {
                            snake_.direction_ = RIGHT_;
                        }
                    else{
                            if(grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                            grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE ||
                            grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                            grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE)
                                {
                                    snake_.direction_ = LEFT_ ;
                                }
                            else if(grid.get(qx-1, qy) == SNAKE|| grid.get(qx-1, qy) == SNAKE_||
                            grid.get(qx-1, qy) == SNAKE_O|| grid.get(qx-1, qy) == FENCE ||
                            grid.get(qx-2, qy) == SNAKE|| grid.get(qx-2, qy) == SNAKE_||
                            grid.get(qx-2, qy) == SNAKE_O|| grid.get(qx-2, qy) == FENCE)
                                {
                                    snake_.direction_ = RIGHT_ ;
                                }
                            else{
                                    var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0)
                                    {
                                        snake_.direction_ = LEFT_;
                                    }
                                    else{
                                        snake_.direction_ = RIGHT_;
                                    }
                                }
                        }
                }

                if(grid.get(qx, qy+1) == SNAKE || grid.get(qx, qy+1) == SNAKE_||
                 grid.get(qx, qy+1) == SNAKE_O|| grid.get(qx, qy+1) == FENCE)
                 {
                 if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                        grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE))
                        {
                            snake_.direction_ = DOWN_;
                        }
                    else if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                        grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE))
                        {
                            snake_.direction_ = LEFT_;
                        }
                    else if((grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy+2) == SNAKE || grid.get(qx, qy+2) == SNAKE_||
                        grid.get(qx, qy+2) == SNAKE_O|| grid.get(qx, qy+2) == FENCE))
                        {
                            snake_.direction_ = RIGHT_;
                        }
                    else{
                            if(grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                            grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE ||
                            grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                            grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE)
                                {
                                    snake_.direction_ = LEFT_ ;
                                }
                            else if(grid.get(qx-1, qy) == SNAKE|| grid.get(qx-1, qy) == SNAKE_||
                            grid.get(qx-1, qy) == SNAKE_O|| grid.get(qx-1, qy) == FENCE ||
                            grid.get(qx-2, qy) == SNAKE|| grid.get(qx-2, qy) == SNAKE_||
                            grid.get(qx-2, qy) == SNAKE_O|| grid.get(qx-2, qy) == FENCE)
                                {
                                    snake_.direction_ = RIGHT_ ;
                                }
                            else{
                                    var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0)
                                    {
                                        snake_.direction_ = LEFT_;
                                    }
                                    else{
                                        snake_.direction_ = RIGHT_;
                                    }
                                }
                        }
                }


            }
            if(snake_.direction_ == UP_){

                if(grid.get(qx, qy-2) == SNAKE || grid.get(qx, qy-2) == SNAKE_||
                 grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE)
                   {
                    if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy-2) == SNAKE || grid.get(qx, qy-2) == SNAKE_||
                        grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE))
                        {
                            snake_.direction_ = UP_;
                        }
                    else if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&
                        (grid.get(qx, qy-2) == SNAKE || grid.get(qx, qy-2) == SNAKE_||
                        grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE))
                        {
                            snake_.direction_ = LEFT_;
                        }
                    else if((grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy-2) == SNAKE || grid.get(qx, qy-2) == SNAKE_||
                        grid.get(qx, qy-2) == SNAKE_O|| grid.get(qx, qy-2) == FENCE))
                        {
                            snake_.direction_ = RIGHT_;
                        }
                    else{
                            if(grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                            grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE ||
                            grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                            grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE)
                                {
                                    snake_.direction_ = LEFT_ ;
                                }
                            else if(grid.get(qx-1, qy) == SNAKE|| grid.get(qx-1, qy) == SNAKE_||
                            grid.get(qx-1, qy) == SNAKE_O|| grid.get(qx-1, qy) == FENCE ||
                            grid.get(qx-2, qy) == SNAKE|| grid.get(qx-2, qy) == SNAKE_||
                            grid.get(qx-2, qy) == SNAKE_O|| grid.get(qx-2, qy) == FENCE)
                                {
                                    snake_.direction_ = RIGHT_ ;
                                }
                            else{
                                    var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0){
                                        snake_.direction_ = RIGHT_;
                                    }
                                    else{
                                        snake_.direction_ = LEFT_;
                                    }
                                }
                        }
                }

                if(grid.get(qx, qy-1) == SNAKE || grid.get(qx, qy-1) == SNAKE_||
                 grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE)
                 {
                 if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy-1) == SNAKE || grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE))
                        {
                            snake_.direction_ = UP_;
                        }
                    else if((grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                       grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE)&&
                        (grid.get(qx, qy-1) == SNAKE || grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE))
                        {
                            snake_.direction_ = LEFT_;
                        }
                    else if((grid.get(qx-1, qy) == SNAKE ||grid.get(qx-1, qy) == SNAKE_||
                       grid.get(qx-1, qy) == SNAKE_O||grid.get(qx-1, qy) == FENCE)&&
                        (grid.get(qx, qy-1) == SNAKE || grid.get(qx, qy-1) == SNAKE_||
                        grid.get(qx, qy-1) == SNAKE_O|| grid.get(qx, qy-1) == FENCE))
                        {
                            snake_.direction_ = RIGHT_;
                        }
                    else{
                            if(grid.get(qx+1, qy) == SNAKE ||grid.get(qx+1, qy) == SNAKE_||
                            grid.get(qx+1, qy) == SNAKE_O||grid.get(qx+1, qy) == FENCE ||
                            grid.get(qx+2, qy) == SNAKE ||grid.get(qx+2, qy) == SNAKE_||
                            grid.get(qx+2, qy) == SNAKE_O||grid.get(qx+2, qy) == FENCE)
                                {
                                    snake_.direction_ = LEFT_ ;
                                }
                            else if(grid.get(qx-1, qy) == SNAKE|| grid.get(qx-1, qy) == SNAKE_||
                            grid.get(qx-1, qy) == SNAKE_O|| grid.get(qx-1, qy) == FENCE ||
                            grid.get(qx-2, qy) == SNAKE|| grid.get(qx-2, qy) == SNAKE_||
                            grid.get(qx-2, qy) == SNAKE_O|| grid.get(qx-2, qy) == FENCE)
                                {
                                    snake_.direction_ = RIGHT_ ;
                                }
                            else{
                                    var direction_condition=Math.floor(Math.random()*100);
                                    if(direction_condition % 2 == 0){
                                        snake_.direction_ = RIGHT_;
                                    }
                                    else{
                                        snake_.direction_ = LEFT_;
                                    }
                                }
                        }
                }

            }


    		// checks all gameover conditions
    		if ((grid.get(nx, ny) === FENCE||
    			grid.get(nx, ny) === SNAKE||
    			grid.get(nx, ny) === SNAKE_||
                grid.get(nx, ny) === SNAKE_O) &&C==1
    		) {
                
                for(var i=0;i<=grid.height-1;i++)
                    {
                        for(var j=0;j<=grid.width-1;j++)
                        {
                            if (grid.get(i, j) === SNAKE)
                            {
                                grid.set(EMPTY,i,j); 
                            }
                        }
                    }
                    SN=0;
                C=0;
                    COUNT++;
    		}


    		if ((grid.get(qx, qy) === FENCE||
    			grid.get(qx, qy) === SNAKE||
    			grid.get(qx, qy) === SNAKE_||
                grid.get(qx, qy) === SNAKE_O)&& C_==1
    		) {
                
                for(var i=0;i<=grid.height-1;i++)
                    {
                        for(var j=0;j<=grid.width-1;j++)
                        {
                            if (grid.get(i, j) === SNAKE_)
                            {
                                grid.set(EMPTY,i,j); 
                            }
                        }
                    }
                    SN_=0;
                C_=0;
                    COUNT++;
    		}



            if ((grid.get(ox, oy) === FENCE||
                grid.get(ox, oy) === SNAKE||
                grid.get(ox, oy) === SNAKE_||
                grid.get(ox, oy) === SNAKE_O)&& C_O==1
            ) {
                
                for(var i=0;i<=grid.height-1;i++)
                    {
                        for(var j=0;j<=grid.width-1;j++)
                        {
                            if (grid.get(i, j) === SNAKE_O)
                            {
                                grid.set(EMPTY,i,j); 
                            }
                        }
                    }
                    SN_O=0;
                C_O=0;
                    COUNT++;
            }

    		if(SN==1)
            {
              grid.set(SNAKE, nx, ny);
    		  snake.insert(nx, ny);
            }
    		if(SN_==3)
            {
                grid.set(SNAKE_, qx, qy);
    		  snake_.insert_(qx, qy);
            }
            if(SN_O==4)
            {
                grid.set(SNAKE_O, ox, oy);
            
              snake_O.insert_O(ox, oy);
            }


            
                if(COUNT==2 && SN==1)
                {
                    alert("BLUE Wins");
                    COUNT=0;            
                }
                if(COUNT==2 && SN_==3)
                {
                    alert("RED Wins");
                    COUNT=0;
                }
                if(COUNT==2 && SN_O==4)
                {
                    alert("PURPLE Wins");
                    COUNT=0;
                }


    	}
    }
    /**
     * Render the grid to the canvas.
     */
    function draw() {
    	// calculate tile-width and -height
    	var tw = canvas.width/grid.width;
    	var th = canvas.height/grid.height;
    	// iterate through the grid and draw all cells
    	for (var x=0; x < grid.width; x++) {
    		for (var y=0; y < grid.height; y++) {
    			// sets the fillstyle depending on the id of
    			// each cell
    			switch (grid.get(x, y)) {
    				case EMPTY:
    					ctx.fillStyle = "#fff";
    					break;
					case FENCE:
    					ctx.fillStyle = "#ff0";
    					break;
    				case SNAKE:
    					ctx.fillStyle = "#00f";//blue 1
    					break;
    				case SNAKE_:
    					ctx.fillStyle = "#f00";// red 2
    					break;
    				case SNAKE_O:
    					ctx.fillStyle = "#f0f";
    					break;
    			}
    			ctx.fillRect(x*tw, y*th, tw, th);
    		}
    	}
    	// changes the fillstyle once more and draws the score
    	// // message to the canvas
    	// ctx.fillStyle = "#000";
    	// ctx.fillText("SCORE: " + score, 10, canvas.height-10);
    }
    // start and run the game
    main();
  </script>
</body>

</html>